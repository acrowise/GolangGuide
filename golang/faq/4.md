# 知道Golang的内存逃逸吗？什么情况下回发生内存逃逸？

A：嗯，了解一些。在编译程序优化理论中，逃逸分析是一种`确定指针动态范围`的方法——分析在程序的哪些地方可以访问到指针。逃逸分析由编译器决定内存分配的位置（分配在`栈`中还是`堆`中），不需要程序员指定。Golang在`编译阶段确定逃逸`。

`栈`（操作系统概念，区别数据结构概念）：可以简单理解为一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统，整个分配内存的过程通过栈的分配和回收都会迅速。

`堆`（操作系统概念，区别数据结构概念）：堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。需要GC来进行回收。

**逃逸分析的用处（为了性能）:**

- `最大的好处应该是减少gc的压力`，不逃逸的对象分配在栈上，函数返回时就回收了资源，不需要gc标记清除。
- 因为逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好
- 同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。

**能引起变量逃逸的到堆上的典型情况：**

- `在方法内把局部变量指针返回`局部变量原本应该在栈中分配，在栈中回收，但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。

  ```go
  package main
  
  import "fmt"
  
  //最常见的情况 在方法内把局部变量指针返回
  func test() *int {
  	var a = 10
  	return &a //发生变量逃逸  从栈逃逸到堆
  }
  
  func main() {
  	p := test()
  	fmt.Println(*p) //fmt.Println(a ...interface{})打印的变量都会发生逃逸
  }
  ```

  通过`go build -gcflags "-m -l"`进行逃逸分析：

  ```go
  .\main.go:7:6: moved to heap: a
  .\main.go:13:13: ... argument does not escape
  .\main.go:13:14: *p escapes to heap
  ```

- `栈空间不足逃逸（空间开辟过大）`

  ```go
  package main
  
  func main() {
  	//实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。
  	s := make([]int, 1000, 1000)
  	// s := make([]int, 100000, 100000)
  
  	for index, _ := range s {
  		s[index] = index
  	}
  }
  ```

  在切片大小为1000时，进行逃逸分析：

  ```go
  .\main.go:17:11: make([]int, 1000, 1000) does not escape
  ```

  增大切片的长度到100000，再进行逃逸分析:

  ```go
  .\main.go:18:11: make([]int, 100000, 100000) escapes to heap
  ```

- `动态类型逃逸`很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。

- `对象指针被多个子程序（如线程 协程）共享使用`