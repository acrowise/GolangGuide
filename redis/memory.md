# Redis中的内存淘汰策略

## 前言

Redis的过期策略，是有**定期删除+惰性删除**两种。

定期好理解，默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。

**为啥不扫描全部设置了过期时间的key呢？** 

假如Redis里面所有的key都有过期时间，都扫描一遍？那太恐怖了，而且我们线上基本上也都是会设置一定的过期时间的。全扫描跟你去查数据库不带where条件不走索引全表扫描一样，100ms一次，Redis累都累死了。

**如果一直没随机到很多key，里面不就存在大量的无效key了？** 

好问题，**惰性删除**，见名知意，惰性嘛，我不主动删，我懒，我等你来查询了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。

**最后就是如果的如果，定期没删，我也没查询，那可咋整？** 

## 这里就引入到了内存淘汰机制！

Redis的`maxmemory`支持的内存淘汰机制使得其成为一种有效的缓存方案，成为memcached的有效替代方案。

当内存达到`maxmemory`后，Redis会按照`maxmemory-policy`启动淘汰策略。

官网上给到的内存淘汰机制是以下几个：

| 淘汰机制        | 特性                                                         |
| --------------- | ------------------------------------------------------------ |
| noeviction      | 内存超限后写命令会返回错误(如OOM, del命令除外)               |
| allkeys-lru     | 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。    |
| volatile-lru    | 仅以设置过期时间key范围内的LRU(如均为设置过期时间，则不会淘汰) |
| allkeys-random  | 回收随机的键使得新添加的数据有空间存放。                     |
| volatile-random | 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 |
| volatile-ttl    | 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 |

**如果没有键满足回收的前提条件的话，策略volatile-lru，volatile-random以及volatile-ttl就和noeviction 差不多了。**

Redis中LRU是近似LRU实现，并不能取出理想LRU理论中最佳淘汰Key，而是通过从小部分采样后的样本中淘汰局部LRU键。**精确LRU会占用较大内存记录历史状态，而近似LRU则用较小内存支出实现近似效果。**

以下是理论LRU和近似LRU的效果对比：

![image-20210408155708558](https://raw.githubusercontent.com/zmk-c/GolangGuide/master/img/20210408155708.png)

- 按时间顺序接入不同键，此时最早写入也就是最佳淘汰键
- 浅灰色区域：被淘汰的键
- 灰色区域：未被淘汰的键
- 绿色区域：新增写入的键

- 在**LRU**实现的理论中，我们希望的是在旧键中的第一半将会过期。**Redis**的**LRU**算法则是概率的过期旧的键。

你可以看到，在都是五个采样的时候Redis 3.0比Redis 2.8要好，Redis2.8中在最后一次访问之间的大多数的对象依然保留着。使用10个采样大小的Redis 3.0的近似值已经非常接近理论的性能。

其实在大家熟悉的**LinkedHashMap**中也实现了LRU算法的，实现如下：

![img](https://user-gold-cdn.xitu.io/2019/11/7/16e43d17e3d8686b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当容量超过100时，开始执行**LRU**策略：将最近最少未使用的 **TimeoutInfoHolder** 对象 **evict** 掉。

真实面试中会让你写LUR算法，你可别搞原始的那个，那真TM多，写不完的，你要么怼上面这个，要么怼下面这个，找一个数据结构实现下Java版本的LRU还是比较容易的，知道啥原理就好了。

![img](https://user-gold-cdn.xitu.io/2019/11/7/16e43d17e5d370b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

从Redis4.0开始，新增LFU淘汰机制，提供更好缓存命中率。LFU(Least Frequently Used)通过记录键使用频率来定位最可能淘汰的键。

对比LRU与LFU的差别：

- 在LRU中，某个键很少被访问，但在刚刚被访问后其被淘汰概率很低，从而出现这类异常持续存在的缓存；相对的，其他可能被访问的键会被淘汰
- 而LFU中，按访问频次淘汰最少被访问的键

Redis 4.0中新增两种LFU淘汰机制：

- volatile-lfu：设置过期时间的键按LFU淘汰
- allkeys-lfu：所有键按LFU淘汰

LFU使用Morris counters计数器占用少量位数来评估每个对象的访问频率，并随时间更新计数器。此机制实现与近似LRU中采样类似。但与LRU不同，LFU提供明确参数来指定计数更新频率。

- lfu-log-factor：0-255之间，饱和因子，值越小代表饱和速度越快
- lfu-decay-time：衰减周期，单位分钟，计数器衰减的分钟数

这两个因子形成一种平衡，通过少量访问 VS 多次访问 的评价标准最终形成对键重要性的评判。



> 参考：[《我们一起进大厂》系列-Redis哨兵、持久化、主从、手撕LRU](https://juejin.cn/post/6844903989184577550)
>