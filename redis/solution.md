# Redis缓存雪崩、击穿、穿透及解决方案

## 1.缓存雪崩

### 概念：

**缓存雪崩是指当缓存服务器重启或者大量缓存集中在某一个时间段失效**，这样在失效的时候，也会给数据库DB带来很大压力。

**举个例子：**目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，可能都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。

<img src="https://raw.githubusercontent.com/zmk-c/GolangGuide/master/img/20210424210831.png" alt="image-20210424210831401" style="zoom:50%;" />

### 解决方案：

处理缓存雪崩简单，在批量往Redis存数据的时候，把**每个Key的失效时间都加个随机值**就好了，这样可以**保证数据不会在同一时间大面积失效**，我相信，Redis这点流量还是顶得住的。

```
setRedis（Key，value，time + Math.random() * 10000）
```

如果Redis是集群部署，将热点数据**均匀分布在不同的Redis库中**也能避免全部失效的问题，或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。

## 2.缓存穿透

### 概念：

**缓存穿透是指key对应的数据在DB并不存在**，每次针对此key的请求从缓存获取不到，请求都会到DB，从而可能压垮DB。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。 

**举个例子：**我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。

<img src="https://raw.githubusercontent.com/zmk-c/GolangGuide/master/img/20210424211455.png" alt="image-20210424211455769" style="zoom:50%;" />

像这种你如果不对参数做校验，数据库id都是大于0的，我一直用小于0的参数去请求你，每次都能绕开Redis直接打到数据库，数据库也查不到，每次都这样，并发高点就容易崩掉了。

### 解决方案：

1. 可以在接口层`增加校验`，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
2. Redis还有一个高级用法[布隆过滤器（Bloom Filter)](./bloomfilter.md)这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

## 3.缓存击穿

### 概念：

**缓存击穿是指key对应的数据存在，但在redis中过期**，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 

缓存击穿跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，**就像在一个完好无损的桶上凿开了一个洞**。

### 解决方案：

可以设置热点数据永远不过期，或者加上互斥锁。

```java
//这里面的锁都是单机玩玩，分布式锁还是得靠lua脚本这样
public static String getData(String Key) throws InterruptedException {
    // 从redis查询数据
    String result = getDataByKV(Key);
    // 参数校验
    if (StringUtils.isBlank(result)) {
        // 获取锁
        if (reenLock.tryLock()) {
            // 去数据库查询
            result = getDataByDB(Key);
            // 校验
            if (StringUtils.isNotBlank(result)) {
                // 搞进缓存
                setDataToKV(Key, result);
            }
            // !!!释放锁 正常会在finally里面释放
            reenLock.unLock();
        } else {
            // 睡一会再拿
            Thread.sleep(100L);
            result = getData(Key);
        }
    }
    return result;
}
```

## 总结

一般避免以上情况发生我们从三个时间段去分析下：

- 事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存 + Hystrix 限流（可以设置每秒的请求，有多少能通过组件）+降级（剩余的未通过的请求，走降级。可以返回一些默认的值，或者友情提示，或者空白的值）避免MySQL 被打死。
- 事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。



> 参考：[《进大厂系列》系列-Redis缓存雪崩、击穿、穿透](https://zhuanlan.zhihu.com/p/89961333)

